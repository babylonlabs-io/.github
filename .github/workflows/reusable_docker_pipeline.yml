name: Docker Build & Publish

on:
  workflow_call:
    inputs:
      dockerfile:
        required: false
        type: string
        description: "Path to Dockerfile"
        default: "Dockerfile"
      dockerContext:
        required: false
        type: string
        description: "The Docker context"
        default: "."
      publish:
        required: true
        type: boolean
      repoName:
        required: false
        type: string
        description: "Custom repository name"
        default: ""
      imageTag:
        required: false
        type: string
        description: "Custom image tag"
        default: ""
      buildArgs:
        type: string
        description: 'Build arguments for Docker'
        required: false
        default: ""
      # Only needed when there are 2 jobs calling to workflow at the same time
      # e.g babylond repo has 2 jobs to build mainnet/testnet images
      buildArtifactPrefix:
        type: string
        description: 'Build artifact prefix'
        required: false
        default: ""
      go-private-repos-authentication:
        description: 'Enable authentication for private repositories'
        type: boolean
        default: false
      private-repos-authentication:
        description: 'Enable authentication for private Vault private repositories'
        type: boolean
        default: false
      docker_scan:
        required: false
        type: boolean
        description: 'Enable Trivy & Hadolint'
        default: true
      hadolint_nofail:
        required: false
        type: boolean
        description: 'Ignore Hadolint failures'
        default: false
      trivy_nofail:
        required: false
        type: boolean
        description: 'Ignore Trivy failures'
        default: false
      secret_nofail:
        required: false
        type: boolean
        description: 'Ignore Trivy secret scan failures'
        default: false
      secret_config:
        required: false
        type: string
        description: 'Path to trivy-secret.yaml for secret scan allow-rules'
        default: ''
      push_to_dockerhub:
        required: false
        type: boolean
        description: 'Push to DockerHub'
        default: false
      push_to_ecr:
        required: false
        type: boolean
        description: 'Push to ECR'
        default: true
      runs_on_amd64:
        required: false
        type: string
        description: 'Runner environment for AMD64'
        default: 'ubuntu-24.04'
      runs_on_arm64:
        required: false
        type: string
        description: 'Runner environment for ARM64'
        default: 'ubuntu-24.04-arm64'
      timeout_minutes:
        required: false
        type: number
        description: 'Job timeout in minutes'
        default: 60
      disable_arm64:
        required: false
        type: boolean
        description: 'Disable ARM64 builds'
        default: false

# For github OIDC authentication to AWS
permissions:
  id-token: write
  contents: read
  security-events: write

jobs:
  prepare-metadata:
    runs-on: ${{ inputs.runs_on_amd64 }}
    timeout-minutes: ${{ inputs.timeout_minutes }}
    outputs:
      image-name: ${{ steps.set_image_name.outputs.IMAGE_NAME }}
      matrix: ${{ steps.set_matrix.outputs.MATRIX }}
    steps:
      - name: Determine image name
        id: set_image_name
        run: |
          if [ -n "${{ inputs.repoName }}" ]; then
            echo "IMAGE_NAME=${{ inputs.repoName }}" >> $GITHUB_OUTPUT
          else
            echo "IMAGE_NAME=$(echo $GITHUB_REPOSITORY | cut -d '/' -f 2)" >> $GITHUB_OUTPUT
          fi

      - name: Set build matrix
        id: set_matrix
        run: |
          if [ "${{ inputs.disable_arm64 }}" == "true" ]; then
            echo 'MATRIX={"include":[{"platform":"linux/amd64","runner":"${{ inputs.runs_on_amd64 }}"}]}' >> $GITHUB_OUTPUT
          else
            echo 'MATRIX={"include":[{"platform":"linux/amd64","runner":"${{ inputs.runs_on_amd64 }}"},{"platform":"linux/arm64","runner":"${{ inputs.runs_on_arm64 }}"}]}' >> $GITHUB_OUTPUT
          fi

  dockerfile_lint:
    runs-on: ${{ inputs.runs_on_amd64 }}
    timeout-minutes: ${{ inputs.timeout_minutes }}
    steps:
    - name: Checkout repository
      if: inputs.docker_scan
      uses: actions/checkout@v4

    - name: Dockerfile Linting
      if: inputs.docker_scan
      uses: hadolint/hadolint-action@v3.1.0
      with:
        output-file: hadolint-result.sarif
        format: sarif
        no-fail: ${{ inputs.hadolint_nofail }}
        dockerfile: ${{ inputs.dockerfile }}

    - name: Add Hadolint results to Job Summary
      if: inputs.docker_scan && always()
      run: |
        echo "## ðŸ³ Hadolint Dockerfile Analysis" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        ISSUES=$(jq -r '.runs[0].results[] | "- **\(.ruleId)** (line \(.locations[0].physicalLocation.region.startLine)): \(.message.text)"' hadolint-result.sarif 2>/dev/null)
        if [ -n "$ISSUES" ]; then
          echo "### Issues Found" >> $GITHUB_STEP_SUMMARY
          echo "$ISSUES" >> $GITHUB_STEP_SUMMARY
        else
          echo "âœ… **No issues found** - Dockerfile follows best practices" >> $GITHUB_STEP_SUMMARY
        fi

    - name: Upload linting results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v4
      if: inputs.docker_scan && always() && github.event.repository.visibility == 'public'
      with:
        sarif_file: hadolint-result.sarif
        category: hadolint

  docker_build:
    runs-on: ${{ matrix.runner }}
    timeout-minutes: ${{ inputs.timeout_minutes }}
    needs:
      - prepare-metadata
      - dockerfile_lint
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.prepare-metadata.outputs.matrix) }}
    steps:
      - name: Prepare
        run: |
          platform=${{ matrix.platform }}
          echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV

      - name: Checkout repository
        uses: actions/checkout@v4

      # ===========================================
      # PRE-PUSH VULNERABILITY SCANNING
      # Scan before any push to ensure only clean images reach registries
      # ===========================================

      # Filesystem scan - fastest fail, catches dependency vulnerabilities before build
      # Only runs on amd64 to avoid redundant scans (source deps are platform-independent)
      - name: Run Trivy filesystem scan
        id: fs-scan
        if: inputs.docker_scan && matrix.platform == 'linux/amd64'
        continue-on-error: true
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'table'
          output: 'trivy-fs.txt'
          exit-code: '1'
          ignore-unfixed: true
          vuln-type: 'library'
          severity: 'CRITICAL'
          trivyignores: ${{ hashFiles('.trivyignore') != '' && '.trivyignore' || '' }}

      # Filesystem secret scan - catches leaked credentials in source code before build
      - name: Run Trivy filesystem secret scan
        id: fs-secret-scan
        if: inputs.docker_scan && matrix.platform == 'linux/amd64'
        continue-on-error: true
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'fs'
          scan-ref: '.'
          scanners: 'secret'
          format: 'table'
          output: 'trivy-fs-secrets.txt'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'
          secret-config: ${{ inputs.secret_config }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        if: inputs.publish && inputs.push_to_dockerhub
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: inputs.publish && inputs.push_to_ecr
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ECR_ACCOUNT }}:role/gha-ecr-push
          role-session-name: gh-docker-build-${{ github.run_id }}
          aws-region: ${{ vars.AWS_ECR_REGION }}

      - name: Login to Amazon ECR
        if: inputs.publish && inputs.push_to_ecr
        run: |
          aws ecr get-login-password --region ${{ vars.AWS_ECR_REGION }} | docker login --username AWS --password-stdin ${{ vars.AWS_ECR_REGISTRY_ID }}

      - name: Create ECR repository if not exists
        if: inputs.publish && inputs.push_to_ecr
        env:
          AWS_REGION: ${{ vars.AWS_ECR_REGION }}
          REPOSITORY_NAME: ${{ needs.prepare-metadata.outputs.image-name }}
        run: |
          # Check if repository exists
          if ! aws ecr describe-repositories --repository-names "${REPOSITORY_NAME}" --region "${AWS_REGION}" > /dev/null 2>&1; then
            echo "Repository ${REPOSITORY_NAME} does not exist. Creating..."
            aws ecr create-repository \
              --repository-name "${REPOSITORY_NAME}" \
              --region "${AWS_REGION}" \
              --image-scanning-configuration scanOnPush=true \
              --image-tag-mutability IMMUTABLE
            echo "Repository ${REPOSITORY_NAME} created successfully"
          else
            echo "Repository ${REPOSITORY_NAME} already exists"
          fi

      # This block is used to not hard-coded the secrets in Build Docker image
      # Secrets are only added when necessary
      - name: Generate and mask build secrets
        id: set-build-secrets
        run: |
          SECRETS=""
          if [ "${{ inputs.go-private-repos-authentication }}" == "true" ]; then
            SECRETS+="GO_PRIVATE_TOKEN=${{ secrets.GO_PRIVATE_TOKEN }}\n"
          fi
          if [ "${{ inputs.private-repos-authentication }}" == "true" ]; then
            SECRETS+="PRIVATE_REPO_TOKEN=${{ secrets.PRIVATE_REPO_TOKEN }}\n"
          fi
          echo "::add-mask::$SECRETS"
          echo "SECRETS<<EOF" >> $GITHUB_OUTPUT
          echo -e "$SECRETS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        shell: bash

      # Build image locally for scanning (not pushed yet)
      - name: Build image for scanning
        id: build-local
        if: inputs.docker_scan
        uses: docker/build-push-action@v6
        with:
          platforms: ${{ matrix.platform }}
          context: ${{ inputs.dockerContext }}
          file: ${{ inputs.dockerfile }}
          build-args: |
            ${{ inputs.buildArgs }}
          secrets: |
            ${{ steps.set-build-secrets.outputs.SECRETS }}
          load: true
          tags: local-scan:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Image scan - catches container vulnerabilities before push
      - name: Run Trivy image scan
        id: image-scan
        if: inputs.docker_scan
        continue-on-error: true
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: 'local-scan:${{ github.sha }}'
          format: 'table'
          output: 'trivy-image.txt'
          exit-code: '1'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL'
          trivyignores: ${{ hashFiles('.trivyignore') != '' && '.trivyignore' || '' }}

      # Image secret scan - catches leaked credentials baked into Docker layers
      - name: Run Trivy image secret scan
        id: image-secret-scan
        if: inputs.docker_scan
        continue-on-error: true
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: 'local-scan:${{ github.sha }}'
          scanners: 'secret'
          format: 'table'
          output: 'trivy-image-secrets.txt'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'
          secret-config: ${{ inputs.secret_config }}

      # Write scan results to Job Summary
      - name: Add scan results to Job Summary
        if: inputs.docker_scan && always()
        env:
          FS_SCAN_OUTCOME: ${{ steps.fs-scan.outcome }}
          IMAGE_SCAN_OUTCOME: ${{ steps.image-scan.outcome }}
          FS_SECRET_OUTCOME: ${{ steps.fs-secret-scan.outcome }}
          IMAGE_SECRET_OUTCOME: ${{ steps.image-secret-scan.outcome }}
        run: |
          echo "## ðŸ³ Container Image Vulnerabilities" >> $GITHUB_STEP_SUMMARY
          echo "Platform: \`${{ matrix.platform }}\`" >> $GITHUB_STEP_SUMMARY
          case "$IMAGE_SCAN_OUTCOME" in
            failure)
              if [ -f trivy-image.txt ]; then
                echo '```' >> $GITHUB_STEP_SUMMARY
                cat trivy-image.txt >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
              else
                echo "âš ï¸ Scan failed but no output file found" >> $GITHUB_STEP_SUMMARY
              fi
              ;;
            success)
              echo "âœ… No critical vulnerabilities found" >> $GITHUB_STEP_SUMMARY
              ;;
            *)
              echo "âš ï¸ Scan did not complete (outcome: $IMAGE_SCAN_OUTCOME)" >> $GITHUB_STEP_SUMMARY
              ;;
          esac
          echo "" >> $GITHUB_STEP_SUMMARY
          # FS scan only runs on amd64 (source deps are platform-independent)
          echo "## ðŸ“¦ Source Dependency Vulnerabilities" >> $GITHUB_STEP_SUMMARY
          if [ "${{ matrix.platform }}" != "linux/amd64" ]; then
            echo "â„¹ï¸ Filesystem scan only runs on linux/amd64" >> $GITHUB_STEP_SUMMARY
          else
            case "$FS_SCAN_OUTCOME" in
              failure)
                if [ -f trivy-fs.txt ]; then
                  echo '```' >> $GITHUB_STEP_SUMMARY
                  cat trivy-fs.txt >> $GITHUB_STEP_SUMMARY
                  echo '```' >> $GITHUB_STEP_SUMMARY
                else
                  echo "âš ï¸ Scan failed but no output file found" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              success)
                echo "âœ… No critical vulnerabilities found" >> $GITHUB_STEP_SUMMARY
                ;;
              *)
                echo "âš ï¸ Scan did not complete (outcome: $FS_SCAN_OUTCOME)" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ”‘ Image Secret Scan" >> $GITHUB_STEP_SUMMARY
          echo "Platform: \`${{ matrix.platform }}\`" >> $GITHUB_STEP_SUMMARY
          case "$IMAGE_SECRET_OUTCOME" in
            failure)
              if [ -f trivy-image-secrets.txt ]; then
                echo '```' >> $GITHUB_STEP_SUMMARY
                cat trivy-image-secrets.txt >> $GITHUB_STEP_SUMMARY
                echo '```' >> $GITHUB_STEP_SUMMARY
              else
                echo "âš ï¸ Scan failed but no output file found" >> $GITHUB_STEP_SUMMARY
              fi
              ;;
            success)
              echo "âœ… No secrets found in image" >> $GITHUB_STEP_SUMMARY
              ;;
            *)
              echo "âš ï¸ Scan did not complete (outcome: $IMAGE_SECRET_OUTCOME)" >> $GITHUB_STEP_SUMMARY
              ;;
          esac
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ”‘ Filesystem Secret Scan" >> $GITHUB_STEP_SUMMARY
          if [ "${{ matrix.platform }}" != "linux/amd64" ]; then
            echo "â„¹ï¸ Filesystem secret scan only runs on linux/amd64" >> $GITHUB_STEP_SUMMARY
          else
            case "$FS_SECRET_OUTCOME" in
              failure)
                if [ -f trivy-fs-secrets.txt ]; then
                  echo '```' >> $GITHUB_STEP_SUMMARY
                  cat trivy-fs-secrets.txt >> $GITHUB_STEP_SUMMARY
                  echo '```' >> $GITHUB_STEP_SUMMARY
                else
                  echo "âš ï¸ Scan failed but no output file found" >> $GITHUB_STEP_SUMMARY
                fi
                ;;
              success)
                echo "âœ… No secrets found in source code" >> $GITHUB_STEP_SUMMARY
                ;;
              *)
                echo "âš ï¸ Scan did not complete (outcome: $FS_SECRET_OUTCOME)" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
          fi

      # Fail the job if vulnerabilities found and trivy_nofail is false
      # Only triggers on actual 'failure' outcome (not skipped/cancelled)
      - name: Enforce vulnerability policy
        if: |
          inputs.docker_scan &&
          inputs.trivy_nofail == false &&
          (steps.fs-scan.outcome == 'failure' || steps.image-scan.outcome == 'failure')
        run: |
          echo "::error::Vulnerabilities found and trivy_nofail is false. Failing the build."
          exit 1

      # Fail the job if secrets found and secret_nofail is false
      - name: Enforce secret scan policy
        if: |
          inputs.docker_scan &&
          inputs.secret_nofail == false &&
          (steps.fs-secret-scan.outcome == 'failure' || steps.image-secret-scan.outcome == 'failure')
        run: |
          echo "::error::Secrets found and secret_nofail is false. Failing the build."
          exit 1

      # SARIF scan for GitHub Security tab (public repos only)
      # Note: Uses broader severity (CRITICAL,HIGH,MEDIUM) for visibility/awareness,
      # while enforcement scans use CRITICAL only to avoid blocking on lower severity
      - name: Run Trivy filesystem scan (SARIF)
        id: sarif-scan
        if: inputs.docker_scan && matrix.platform == 'linux/amd64' && github.event.repository.visibility == 'public'
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-fs.sarif'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'library'
          severity: 'CRITICAL,HIGH,MEDIUM'
          trivyignores: ${{ hashFiles('.trivyignore') != '' && '.trivyignore' || '' }}

      - name: Upload SARIF to GitHub Security tab
        if: inputs.docker_scan && matrix.platform == 'linux/amd64' && github.event.repository.visibility == 'public' && steps.sarif-scan.outcome == 'success'
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-fs.sarif'
          category: trivy-fs-${{ env.PLATFORM_PAIR }}

      # ===========================================
      # PUSH TO REGISTRIES (only after scans pass)
      # ===========================================

      - name: Build and push to Docker Hub
        id: build-dockerhub
        if: inputs.publish && inputs.push_to_dockerhub
        uses: docker/build-push-action@v6
        with:
          platforms: ${{ matrix.platform }}
          context: ${{ inputs.dockerContext }}
          file: ${{ inputs.dockerfile }}
          build-args: |
            ${{ inputs.buildArgs }}
          secrets: |
            ${{ steps.set-build-secrets.outputs.SECRETS }}
          cache-from: type=gha
          outputs: type=image,name=${{ vars.DOCKERHUB_REGISTRY_ID || 'babylonlabs' }}/${{ needs.prepare-metadata.outputs.image-name }},push-by-digest=true,push=${{ inputs.publish }}

      - name: Build and push to ECR
        id: build-ecr
        if: inputs.publish && inputs.push_to_ecr
        uses: docker/build-push-action@v6
        with:
          platforms: ${{ matrix.platform }}
          context: ${{ inputs.dockerContext }}
          file: ${{ inputs.dockerfile }}
          build-args: |
            ${{ inputs.buildArgs }}
          secrets: |
            ${{ steps.set-build-secrets.outputs.SECRETS }}
          cache-from: type=gha
          outputs: type=image,name=${{ vars.AWS_ECR_REGISTRY_ID || 'babylonlabs' }}/${{ needs.prepare-metadata.outputs.image-name }},push-by-digest=true,push=${{ inputs.publish }}

      - name: Export digest Docker Hub
        if: inputs.publish && inputs.push_to_dockerhub
        run: |
          mkdir -p /tmp/digests/dockerhub
          digest="${{ steps.build-dockerhub.outputs.digest }}"
          echo "$digest" > "/tmp/digests/dockerhub/${digest#sha256:}"

      - name: Export digest ECR
        if: inputs.publish && inputs.push_to_ecr
        run: |
          mkdir -p /tmp/digests/ecr
          digest="${{ steps.build-ecr.outputs.digest }}"
          echo "$digest" > "/tmp/digests/ecr/${digest#sha256:}"

      - name: Upload Docker Hub digest
        if: inputs.publish && inputs.push_to_dockerhub
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.buildArtifactPrefix }}digests-dockerhub-${{ needs.prepare-metadata.outputs.image-name }}-${{ env.PLATFORM_PAIR }}
          path: /tmp/digests/dockerhub/*
          if-no-files-found: error
          retention-days: 1

      - name: Upload ECR digest
        if: inputs.publish && inputs.push_to_ecr
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.buildArtifactPrefix }}digests-ecr-${{ needs.prepare-metadata.outputs.image-name }}-${{ env.PLATFORM_PAIR }}
          path: /tmp/digests/ecr/*
          if-no-files-found: error
          retention-days: 1

  merge_dockerhub:
    runs-on: ${{ inputs.runs_on_amd64 }}
    timeout-minutes: ${{ inputs.timeout_minutes }}
    if: inputs.publish && inputs.push_to_dockerhub
    needs:
      - docker_build
      - prepare-metadata
    outputs:
      dockerhub_imgver: ${{ steps.meta.outputs.version }}
    steps:
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: ${{ inputs.buildArtifactPrefix }}digests-dockerhub-${{ needs.prepare-metadata.outputs.image-name }}-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ vars.DOCKERHUB_REGISTRY_ID }}/${{ needs.prepare-metadata.outputs.image-name }}
          # If inputs.imageTag is available, other tags will be ignored
          # Priority only affects the order of tag generation, not which tag is chosen
          tags: |
            type=sha,enable=${{ !inputs.imageTag }},priority=100,prefix=,suffix=,format=long
            type=ref,enable=${{ !inputs.imageTag }},priority=200,prefix=,suffix=,event=tag
            type=raw,enable=${{ !!inputs.imageTag }},priority=300,value=${{ inputs.imageTag }}

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Create manifest list and push
        working-directory: /tmp/digests
        run: |
          first_tag=$(jq -r '.tags[0] // empty' <<< "$DOCKER_METADATA_OUTPUT_JSON")
          if [ -z "$first_tag" ]; then
            echo "No tag found in DOCKER_METADATA_OUTPUT_JSON"; exit 1
          fi
          digests=$(printf "${{ vars.DOCKERHUB_REGISTRY_ID }}/${{ needs.prepare-metadata.outputs.image-name }}@sha256:%s " $(ls /tmp/digests))
          docker buildx imagetools create -t "$first_tag" $digests

      - name: Inspect image
        run: |
          docker buildx imagetools inspect ${{ vars.DOCKERHUB_REGISTRY_ID }}/${{ needs.prepare-metadata.outputs.image-name }}:${{ steps.meta.outputs.version }}

  merge_ecr:
    runs-on: ${{ inputs.runs_on_amd64 }}
    timeout-minutes: ${{ inputs.timeout_minutes }}
    if: inputs.publish && inputs.push_to_ecr
    needs:
      - docker_build
      - prepare-metadata
    outputs:
      ecr_imgver: ${{ steps.meta.outputs.version }}
    steps:
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: ${{ inputs.buildArtifactPrefix }}digests-ecr-${{ needs.prepare-metadata.outputs.image-name }}-*
          merge-multiple: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ vars.AWS_ECR_REGISTRY_ID }}/${{ needs.prepare-metadata.outputs.image-name }}
          flavor: |
            latest=false
          tags: |
            type=sha,enable=${{ !inputs.imageTag }},priority=100,prefix=,suffix=,format=long
            type=ref,enable=${{ !inputs.imageTag }},priority=200,prefix=,suffix=,event=tag
            type=raw,enable=${{ !!inputs.imageTag }},priority=300,value=${{ inputs.imageTag }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: inputs.publish && inputs.push_to_ecr
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ECR_ACCOUNT }}:role/gha-ecr-push
          role-session-name: gh-docker-build-${{ github.run_id }}
          aws-region: ${{ vars.AWS_ECR_REGION }}

      - name: Login to Amazon ECR
        if: inputs.publish && inputs.push_to_ecr
        run: |
          aws ecr get-login-password --region ${{ vars.AWS_ECR_REGION }} | docker login --username AWS --password-stdin ${{ vars.AWS_ECR_REGISTRY_ID }}

      - name: Create manifest list and push
        working-directory: /tmp/digests/
        run: |
          first_tag=$(jq -r '.tags[0] // empty' <<< "$DOCKER_METADATA_OUTPUT_JSON")
          if [ -z "$first_tag" ]; then
            echo "No tag found in DOCKER_METADATA_OUTPUT_JSON"; exit 1
          fi
          digests=$(printf "${{ vars.AWS_ECR_REGISTRY_ID }}/${{ needs.prepare-metadata.outputs.image-name }}@sha256:%s " $(ls /tmp/digests))
          docker buildx imagetools create -t "$first_tag" $digests

      - name: Inspect image
        run: |
          docker buildx imagetools inspect ${{ vars.AWS_ECR_REGISTRY_ID }}/${{ needs.prepare-metadata.outputs.image-name }}:${{ steps.meta.outputs.version }}
